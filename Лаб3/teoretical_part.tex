\chapter{Теоретическая часть}
\section{Базис языка}

Базис состоит из:
\begin{enumerate}
	\item структуры, атомы;
	\item встроенные (примитивные) функции (\texttt{atom}, \texttt{eq}, \texttt{cons}, \texttt{car}, \texttt{cdr});
	\item специальные функции и функционалы, управляющие обработкой структур, представляющих вычислимые выражения (\texttt{quote}, \texttt{cond}, \texttt{lambda}, \texttt{label}, \texttt{eval}).
\end{enumerate}

\section{Классификация функций}

Функции в \texttt{Lisp} классифицируют следующим образом:

\begin{itemize}
	\item чистые математические функции;
	\item рекурсивные функции;
	\item специальные функции --- формы (сегодня 2 аргумента, завтра - 5);
	\item псевдофункции (создают эффект на внешнем устройстве);
	\item функции с вариативными значениями, из которых выбирается 1;
	\item функции высших порядков --- функционал: используется для синтаксического управления программ (абстракция языка).
\end{itemize}

По назначению функции разделяются следующим образом:

\begin{itemize}
	\item конструкторы --- создают значение (\texttt{cons}, например);
	\item селекторы --- получают доступ по адресу (\texttt{car}, \texttt{cdr});
	\item предикаты --- возвращают \texttt{Nil}, \texttt{T}.
	\item функции сравнения -- такие как: \texttt{eq}, \texttt{eql}, \texttt{equal}, \texttt{equalp}.
\end{itemize}

\section{Способы создания функций}

Функции в \texttt{Lisp} можно задавать следующими способами:

\subsection*{\texttt{Lambda}-выражение}

Синтаксис:

\texttt{(lambda <$\lambda$-список> форма)}

Пример:

\begin{lstlisting} [
	float=h!,
	frame=single,
	numbers=left,
	abovecaptionskip=-5pt,
	caption={Функция определенная Lambda-выражением},
	label={cc:1},
	language={Lisp},
	]
	(lambda (a b) (sqrt (+ (* a a) (* b b))))
\end{lstlisting}

\subsection*{Именованная функция}

Синтаксис:

\texttt{(defun <имя функции> <$\lambda$-выражение>)}

Пример:

\begin{lstlisting} [
	float=h!,
	frame=single,
	numbers=left,
	abovecaptionskip=-5pt,
	caption={Пример определения именованной функции},
	label={cc:2},
	language={Lisp},
	]
	(defun hyp (a b) (sqrt (+ (* a a) (* b b))))
\end{lstlisting}

